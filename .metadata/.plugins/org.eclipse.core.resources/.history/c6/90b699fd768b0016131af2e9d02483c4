
public class SurroundedRegions {
    
    public int totalRow = 0;
    public int totalLine = 0;
    Set<Position> visited = new HashSet<Position>();
    
    class Position {
        public int row;
        public int line;
        Position(int row, int line) {
            this.row = row;
            this.line = line;
        }
    }

    public void solve(char[][] board) {
        totalRow = board.length;
        totalLine = totalRow != 0 ? board[0].length : 0;
        if (totalRow == 0 || totalLine == 0) {
            return;
        }

        List<Set<Position>> regionSetList = new ArrayList<Set<Position>>();
        Set<Position> regionSet = new HashSet<Position>();
        
        // find all regions where "o" are connected
        for (int row = 0; row < board.length; row++) {
            if (board[0] != null) {
                for (int line = 0; line < board[0].length; line++) {
                    if (board[row][line] == 'O') {
                        Position pos = new Position(row, line);
                        if (!visited.contains(pos)) {
                            findNeighborOWidth(board, pos, regionSet);
                            regionSetList.add(regionSet);
                            regionSet = new HashSet<Position>();
                        }
                    }
                }
            }
        }
        
        // check whether this region is surrounded by "x"
        List<Integer> regionsNeedFlipper = new ArrayList<Integer>();
        for (int index = 0; index < regionSetList.size(); index++) {
            if (checkWhetherSurroundedByX(board, regionSetList.get(index))) {
                regionsNeedFlipper.add(index);
            }
        }
        
        // flipper the regions that are surrounded by "x"
        for (int index : regionsNeedFlipper) {
            for(Position pos : regionSetList.get(index)) {
                board[pos.row][pos.line] = 'X';
            }
        }
    }

    public Position getPosition(Position pos, int rowOffset, int lineOffset) {
        return new Position(pos.row + rowOffset, pos.line + lineOffset);
    }
    
    public void findNeighborODepth(char[][] board, Position pos, Set<Position> regionSet) {
        if (pos.row < totalRow && pos.row >= 0 && pos.line < totalLine && pos.line >= 0) {
            if (board[pos.row][pos.line] == 'O' && !visited.contains(pos)) {
                regionSet.add(pos);
                visited.add(pos);
                findNeighborODepth(board, getPosition(pos,-1,  0), regionSet); // up
                findNeighborODepth(board, getPosition(pos, 1,  0), regionSet); // down
                findNeighborODepth(board, getPosition(pos, 0, -1), regionSet); // left
                findNeighborODepth(board, getPosition(pos, 0,  1), regionSet); // right
            } else {
                return;
            }
        } else {
            return;
        }
    }
    
    public void findNeighborOWidth(char[][] board, Position rootPos, Set<Position> regionSet) {
        Queue<Position> queue = new LinkedList<Position>();
        queue.offer(rootPos);
        while(!queue.isEmpty()) {
            Position pos = queue.poll();
            if (!visited.contains(pos)) {
                if (pos.row < totalRow && pos.row >= 0 && pos.line < totalLine && pos.line >= 0) {
                    if (board[pos.row][pos.line] == 'O') {
                        regionSet.add(pos);
                        visited.add(pos);
                        queue.offer(getPosition(pos,-1,  0)); // up
                        queue.offer(getPosition(pos, 1,  0)); // down
                        queue.offer(getPosition(pos, 0, -1)); // left
                        queue.offer(getPosition(pos, 0,  1)); // right
                    }
                }
            }
        }
    }
    
    public boolean checkWhetherSurroundedByX(char[][] board, Set<Position> regionSet) {
        for (Position pos : regionSet) {
            if (pos.row+1 < totalRow && pos.row-1 >= 0 && pos.line+1 < totalLine && pos.line-1 >= 0){
                Position posUp = getPosition(pos,-1,  0);
                Position posDown = getPosition(pos, 1,  0);
                Position posLeft = getPosition(pos, 0, -1);
                Position posRight = getPosition(pos, 0,  1);
                if (isXOrInRegion(board, regionSet, posUp) && isXOrInRegion(board, regionSet, posDown)
                && isXOrInRegion(board, regionSet, posLeft) && isXOrInRegion(board, regionSet, posRight)) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        return false;
    }
    
    public boolean isXOrInRegion(char[][] board, Set<Position> regionSet, Position pos) {
        if (board[pos.row][pos.line] == 'X' || regionSet.contains(pos)) {
            return true;
        } else {
            return false;
        }
    }
}
